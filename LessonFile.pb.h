// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LessonFile.proto

#ifndef PROTOBUF_LessonFile_2eproto__INCLUDED
#define PROTOBUF_LessonFile_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Guitar_learning {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_LessonFile_2eproto();
void protobuf_AssignDesc_LessonFile_2eproto();
void protobuf_ShutdownFile_LessonFile_2eproto();

class LessonFile;
class LessonFile_Tone;
class LessonFile_Note;
class LessonFile_Bar;
class LessonFile_Track;
class LessonFile_bgMysic;
class LessonFile_Visuals;
class LessonFile_Lesson;

enum LessonFile_bgMysic_bgType {
  LessonFile_bgMysic_bgType_NONE = 0,
  LessonFile_bgMysic_bgType_WMA = 1,
  LessonFile_bgMysic_bgType_MP3 = 2,
  LessonFile_bgMysic_bgType_VORIBS = 3
};
bool LessonFile_bgMysic_bgType_IsValid(int value);
const LessonFile_bgMysic_bgType LessonFile_bgMysic_bgType_bgType_MIN = LessonFile_bgMysic_bgType_NONE;
const LessonFile_bgMysic_bgType LessonFile_bgMysic_bgType_bgType_MAX = LessonFile_bgMysic_bgType_VORIBS;
const int LessonFile_bgMysic_bgType_bgType_ARRAYSIZE = LessonFile_bgMysic_bgType_bgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LessonFile_bgMysic_bgType_descriptor();
inline const ::std::string& LessonFile_bgMysic_bgType_Name(LessonFile_bgMysic_bgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LessonFile_bgMysic_bgType_descriptor(), value);
}
inline bool LessonFile_bgMysic_bgType_Parse(
    const ::std::string& name, LessonFile_bgMysic_bgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LessonFile_bgMysic_bgType>(
    LessonFile_bgMysic_bgType_descriptor(), name, value);
}
enum LessonFile_Visuals_visualType {
  LessonFile_Visuals_visualType_NONE = 0,
  LessonFile_Visuals_visualType_WMV = 1,
  LessonFile_Visuals_visualType_MPEG2 = 2,
  LessonFile_Visuals_visualType_MPEG4 = 3,
  LessonFile_Visuals_visualType_DIVX = 4,
  LessonFile_Visuals_visualType_XVID = 5,
  LessonFile_Visuals_visualType_X264 = 6
};
bool LessonFile_Visuals_visualType_IsValid(int value);
const LessonFile_Visuals_visualType LessonFile_Visuals_visualType_visualType_MIN = LessonFile_Visuals_visualType_NONE;
const LessonFile_Visuals_visualType LessonFile_Visuals_visualType_visualType_MAX = LessonFile_Visuals_visualType_X264;
const int LessonFile_Visuals_visualType_visualType_ARRAYSIZE = LessonFile_Visuals_visualType_visualType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LessonFile_Visuals_visualType_descriptor();
inline const ::std::string& LessonFile_Visuals_visualType_Name(LessonFile_Visuals_visualType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LessonFile_Visuals_visualType_descriptor(), value);
}
inline bool LessonFile_Visuals_visualType_Parse(
    const ::std::string& name, LessonFile_Visuals_visualType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LessonFile_Visuals_visualType>(
    LessonFile_Visuals_visualType_descriptor(), name, value);
}
enum LessonFile_NoteLength {
  LessonFile_NoteLength_nl64 = 1,
  LessonFile_NoteLength_nl32 = 2,
  LessonFile_NoteLength_nl16 = 4,
  LessonFile_NoteLength_nl8 = 8,
  LessonFile_NoteLength_nl4 = 16,
  LessonFile_NoteLength_nl2 = 32,
  LessonFile_NoteLength_nl1 = 64
};
bool LessonFile_NoteLength_IsValid(int value);
const LessonFile_NoteLength LessonFile_NoteLength_NoteLength_MIN = LessonFile_NoteLength_nl64;
const LessonFile_NoteLength LessonFile_NoteLength_NoteLength_MAX = LessonFile_NoteLength_nl1;
const int LessonFile_NoteLength_NoteLength_ARRAYSIZE = LessonFile_NoteLength_NoteLength_MAX + 1;

const ::google::protobuf::EnumDescriptor* LessonFile_NoteLength_descriptor();
inline const ::std::string& LessonFile_NoteLength_Name(LessonFile_NoteLength value) {
  return ::google::protobuf::internal::NameOfEnum(
    LessonFile_NoteLength_descriptor(), value);
}
inline bool LessonFile_NoteLength_Parse(
    const ::std::string& name, LessonFile_NoteLength* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LessonFile_NoteLength>(
    LessonFile_NoteLength_descriptor(), name, value);
}
enum LessonFile_ClefType {
  LessonFile_ClefType_treble = 1,
  LessonFile_ClefType_bass = 2
};
bool LessonFile_ClefType_IsValid(int value);
const LessonFile_ClefType LessonFile_ClefType_ClefType_MIN = LessonFile_ClefType_treble;
const LessonFile_ClefType LessonFile_ClefType_ClefType_MAX = LessonFile_ClefType_bass;
const int LessonFile_ClefType_ClefType_ARRAYSIZE = LessonFile_ClefType_ClefType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LessonFile_ClefType_descriptor();
inline const ::std::string& LessonFile_ClefType_Name(LessonFile_ClefType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LessonFile_ClefType_descriptor(), value);
}
inline bool LessonFile_ClefType_Parse(
    const ::std::string& name, LessonFile_ClefType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LessonFile_ClefType>(
    LessonFile_ClefType_descriptor(), name, value);
}
// ===================================================================

class LessonFile_Tone : public ::google::protobuf::Message {
 public:
  LessonFile_Tone();
  virtual ~LessonFile_Tone();
  
  LessonFile_Tone(const LessonFile_Tone& from);
  
  inline LessonFile_Tone& operator=(const LessonFile_Tone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Tone& default_instance();
  
  void Swap(LessonFile_Tone* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Tone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Tone& from);
  void MergeFrom(const LessonFile_Tone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double pitch = 1;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 1;
  inline double pitch() const;
  inline void set_pitch(double value);
  
  // optional uint32 str = 2 [default = 0];
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline ::google::protobuf::uint32 str() const;
  inline void set_str(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Tone)
 private:
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_str();
  inline void clear_has_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double pitch_;
  ::google::protobuf::uint32 str_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Tone* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_Note : public ::google::protobuf::Message {
 public:
  LessonFile_Note();
  virtual ~LessonFile_Note();
  
  LessonFile_Note(const LessonFile_Note& from);
  
  inline LessonFile_Note& operator=(const LessonFile_Note& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Note& default_instance();
  
  void Swap(LessonFile_Note* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Note* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Note& from);
  void MergeFrom(const LessonFile_Note& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Guitar_learning.LessonFile.NoteLength length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::Guitar_learning::LessonFile_NoteLength length() const;
  inline void set_length(::Guitar_learning::LessonFile_NoteLength value);
  
  // required uint32 extension = 2;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 2;
  inline ::google::protobuf::uint32 extension() const;
  inline void set_extension(::google::protobuf::uint32 value);
  
  // optional bool continueTo = 3;
  inline bool has_continueto() const;
  inline void clear_continueto();
  static const int kContinueToFieldNumber = 3;
  inline bool continueto() const;
  inline void set_continueto(bool value);
  
  // optional bool continuedFrom = 4;
  inline bool has_continuedfrom() const;
  inline void clear_continuedfrom();
  static const int kContinuedFromFieldNumber = 4;
  inline bool continuedfrom() const;
  inline void set_continuedfrom(bool value);
  
  // optional bool slideTo = 5;
  inline bool has_slideto() const;
  inline void clear_slideto();
  static const int kSlideToFieldNumber = 5;
  inline bool slideto() const;
  inline void set_slideto(bool value);
  
  // optional bool slidedFrom = 6;
  inline bool has_slidedfrom() const;
  inline void clear_slidedfrom();
  static const int kSlidedFromFieldNumber = 6;
  inline bool slidedfrom() const;
  inline void set_slidedfrom(bool value);
  
  // optional bool vibrato = 7;
  inline bool has_vibrato() const;
  inline void clear_vibrato();
  static const int kVibratoFieldNumber = 7;
  inline bool vibrato() const;
  inline void set_vibrato(bool value);
  
  // optional bool HO = 8;
  inline bool has_ho() const;
  inline void clear_ho();
  static const int kHOFieldNumber = 8;
  inline bool ho() const;
  inline void set_ho(bool value);
  
  // optional bool PO = 9;
  inline bool has_po() const;
  inline void clear_po();
  static const int kPOFieldNumber = 9;
  inline bool po() const;
  inline void set_po(bool value);
  
  // optional uint32 grouping = 10;
  inline bool has_grouping() const;
  inline void clear_grouping();
  static const int kGroupingFieldNumber = 10;
  inline ::google::protobuf::uint32 grouping() const;
  inline void set_grouping(::google::protobuf::uint32 value);
  
  // optional uint32 ungrouping = 11;
  inline bool has_ungrouping() const;
  inline void clear_ungrouping();
  static const int kUngroupingFieldNumber = 11;
  inline ::google::protobuf::uint32 ungrouping() const;
  inline void set_ungrouping(::google::protobuf::uint32 value);
  
  // optional bool in_group = 12;
  inline bool has_in_group() const;
  inline void clear_in_group();
  static const int kInGroupFieldNumber = 12;
  inline bool in_group() const;
  inline void set_in_group(bool value);
  
  // repeated .Guitar_learning.LessonFile.Tone tone = 13;
  inline int tone_size() const;
  inline void clear_tone();
  static const int kToneFieldNumber = 13;
  inline const ::Guitar_learning::LessonFile_Tone& tone(int index) const;
  inline ::Guitar_learning::LessonFile_Tone* mutable_tone(int index);
  inline ::Guitar_learning::LessonFile_Tone* add_tone();
  inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Tone >&
      tone() const;
  inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Tone >*
      mutable_tone();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Note)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_continueto();
  inline void clear_has_continueto();
  inline void set_has_continuedfrom();
  inline void clear_has_continuedfrom();
  inline void set_has_slideto();
  inline void clear_has_slideto();
  inline void set_has_slidedfrom();
  inline void clear_has_slidedfrom();
  inline void set_has_vibrato();
  inline void clear_has_vibrato();
  inline void set_has_ho();
  inline void clear_has_ho();
  inline void set_has_po();
  inline void clear_has_po();
  inline void set_has_grouping();
  inline void clear_has_grouping();
  inline void set_has_ungrouping();
  inline void clear_has_ungrouping();
  inline void set_has_in_group();
  inline void clear_has_in_group();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int length_;
  ::google::protobuf::uint32 extension_;
  bool continueto_;
  bool continuedfrom_;
  bool slideto_;
  bool slidedfrom_;
  bool vibrato_;
  bool ho_;
  bool po_;
  bool in_group_;
  ::google::protobuf::uint32 grouping_;
  ::google::protobuf::uint32 ungrouping_;
  ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Tone > tone_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Note* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_Bar : public ::google::protobuf::Message {
 public:
  LessonFile_Bar();
  virtual ~LessonFile_Bar();
  
  LessonFile_Bar(const LessonFile_Bar& from);
  
  inline LessonFile_Bar& operator=(const LessonFile_Bar& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Bar& default_instance();
  
  void Swap(LessonFile_Bar* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Bar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Bar& from);
  void MergeFrom(const LessonFile_Bar& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional uint32 length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);
  
  // optional bool repeat_start = 3;
  inline bool has_repeat_start() const;
  inline void clear_repeat_start();
  static const int kRepeatStartFieldNumber = 3;
  inline bool repeat_start() const;
  inline void set_repeat_start(bool value);
  
  // optional uint32 repeat_end = 4 [default = 1];
  inline bool has_repeat_end() const;
  inline void clear_repeat_end();
  static const int kRepeatEndFieldNumber = 4;
  inline ::google::protobuf::uint32 repeat_end() const;
  inline void set_repeat_end(::google::protobuf::uint32 value);
  
  // optional uint32 next_repeat_ending = 5 [default = 0];
  inline bool has_next_repeat_ending() const;
  inline void clear_next_repeat_ending();
  static const int kNextRepeatEndingFieldNumber = 5;
  inline ::google::protobuf::uint32 next_repeat_ending() const;
  inline void set_next_repeat_ending(::google::protobuf::uint32 value);
  
  // optional string bar_chord = 6;
  inline bool has_bar_chord() const;
  inline void clear_bar_chord();
  static const int kBarChordFieldNumber = 6;
  inline const ::std::string& bar_chord() const;
  inline void set_bar_chord(const ::std::string& value);
  inline void set_bar_chord(const char* value);
  inline void set_bar_chord(const char* value, size_t size);
  inline ::std::string* mutable_bar_chord();
  inline ::std::string* release_bar_chord();
  
  // repeated .Guitar_learning.LessonFile.Note notes = 7;
  inline int notes_size() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 7;
  inline const ::Guitar_learning::LessonFile_Note& notes(int index) const;
  inline ::Guitar_learning::LessonFile_Note* mutable_notes(int index);
  inline ::Guitar_learning::LessonFile_Note* add_notes();
  inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Note >&
      notes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Note >*
      mutable_notes();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Bar)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_repeat_start();
  inline void clear_has_repeat_start();
  inline void set_has_repeat_end();
  inline void clear_has_repeat_end();
  inline void set_has_next_repeat_ending();
  inline void clear_has_next_repeat_ending();
  inline void set_has_bar_chord();
  inline void clear_has_bar_chord();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 length_;
  bool repeat_start_;
  ::google::protobuf::uint32 repeat_end_;
  ::std::string* bar_chord_;
  ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Note > notes_;
  ::google::protobuf::uint32 next_repeat_ending_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Bar* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_Track : public ::google::protobuf::Message {
 public:
  LessonFile_Track();
  virtual ~LessonFile_Track();
  
  LessonFile_Track(const LessonFile_Track& from);
  
  inline LessonFile_Track& operator=(const LessonFile_Track& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Track& default_instance();
  
  void Swap(LessonFile_Track* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Track& from);
  void MergeFrom(const LessonFile_Track& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Guitar_learning.LessonFile.ClefType clef = 1;
  inline bool has_clef() const;
  inline void clear_clef();
  static const int kClefFieldNumber = 1;
  inline ::Guitar_learning::LessonFile_ClefType clef() const;
  inline void set_clef(::Guitar_learning::LessonFile_ClefType value);
  
  // required uint32 beat_count = 2;
  inline bool has_beat_count() const;
  inline void clear_beat_count();
  static const int kBeatCountFieldNumber = 2;
  inline ::google::protobuf::uint32 beat_count() const;
  inline void set_beat_count(::google::protobuf::uint32 value);
  
  // required uint32 beat_length = 3;
  inline bool has_beat_length() const;
  inline void clear_beat_length();
  static const int kBeatLengthFieldNumber = 3;
  inline ::google::protobuf::uint32 beat_length() const;
  inline void set_beat_length(::google::protobuf::uint32 value);
  
  // repeated .Guitar_learning.LessonFile.Bar bars = 4;
  inline int bars_size() const;
  inline void clear_bars();
  static const int kBarsFieldNumber = 4;
  inline const ::Guitar_learning::LessonFile_Bar& bars(int index) const;
  inline ::Guitar_learning::LessonFile_Bar* mutable_bars(int index);
  inline ::Guitar_learning::LessonFile_Bar* add_bars();
  inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Bar >&
      bars() const;
  inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Bar >*
      mutable_bars();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Track)
 private:
  inline void set_has_clef();
  inline void clear_has_clef();
  inline void set_has_beat_count();
  inline void clear_has_beat_count();
  inline void set_has_beat_length();
  inline void clear_has_beat_length();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int clef_;
  ::google::protobuf::uint32 beat_count_;
  ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Bar > bars_;
  ::google::protobuf::uint32 beat_length_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Track* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_bgMysic : public ::google::protobuf::Message {
 public:
  LessonFile_bgMysic();
  virtual ~LessonFile_bgMysic();
  
  LessonFile_bgMysic(const LessonFile_bgMysic& from);
  
  inline LessonFile_bgMysic& operator=(const LessonFile_bgMysic& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_bgMysic& default_instance();
  
  void Swap(LessonFile_bgMysic* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_bgMysic* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_bgMysic& from);
  void MergeFrom(const LessonFile_bgMysic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LessonFile_bgMysic_bgType bgType;
  static const bgType NONE = LessonFile_bgMysic_bgType_NONE;
  static const bgType WMA = LessonFile_bgMysic_bgType_WMA;
  static const bgType MP3 = LessonFile_bgMysic_bgType_MP3;
  static const bgType VORIBS = LessonFile_bgMysic_bgType_VORIBS;
  static inline bool bgType_IsValid(int value) {
    return LessonFile_bgMysic_bgType_IsValid(value);
  }
  static const bgType bgType_MIN =
    LessonFile_bgMysic_bgType_bgType_MIN;
  static const bgType bgType_MAX =
    LessonFile_bgMysic_bgType_bgType_MAX;
  static const int bgType_ARRAYSIZE =
    LessonFile_bgMysic_bgType_bgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  bgType_descriptor() {
    return LessonFile_bgMysic_bgType_descriptor();
  }
  static inline const ::std::string& bgType_Name(bgType value) {
    return LessonFile_bgMysic_bgType_Name(value);
  }
  static inline bool bgType_Parse(const ::std::string& name,
      bgType* value) {
    return LessonFile_bgMysic_bgType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Guitar_learning.LessonFile.bgMysic.bgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Guitar_learning::LessonFile_bgMysic_bgType type() const;
  inline void set_type(::Guitar_learning::LessonFile_bgMysic_bgType value);
  
  // optional bytes header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const void* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  
  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.bgMysic)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* header_;
  ::std::string* data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_bgMysic* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_Visuals : public ::google::protobuf::Message {
 public:
  LessonFile_Visuals();
  virtual ~LessonFile_Visuals();
  
  LessonFile_Visuals(const LessonFile_Visuals& from);
  
  inline LessonFile_Visuals& operator=(const LessonFile_Visuals& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Visuals& default_instance();
  
  void Swap(LessonFile_Visuals* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Visuals* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Visuals& from);
  void MergeFrom(const LessonFile_Visuals& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LessonFile_Visuals_visualType visualType;
  static const visualType NONE = LessonFile_Visuals_visualType_NONE;
  static const visualType WMV = LessonFile_Visuals_visualType_WMV;
  static const visualType MPEG2 = LessonFile_Visuals_visualType_MPEG2;
  static const visualType MPEG4 = LessonFile_Visuals_visualType_MPEG4;
  static const visualType DIVX = LessonFile_Visuals_visualType_DIVX;
  static const visualType XVID = LessonFile_Visuals_visualType_XVID;
  static const visualType X264 = LessonFile_Visuals_visualType_X264;
  static inline bool visualType_IsValid(int value) {
    return LessonFile_Visuals_visualType_IsValid(value);
  }
  static const visualType visualType_MIN =
    LessonFile_Visuals_visualType_visualType_MIN;
  static const visualType visualType_MAX =
    LessonFile_Visuals_visualType_visualType_MAX;
  static const int visualType_ARRAYSIZE =
    LessonFile_Visuals_visualType_visualType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  visualType_descriptor() {
    return LessonFile_Visuals_visualType_descriptor();
  }
  static inline const ::std::string& visualType_Name(visualType value) {
    return LessonFile_Visuals_visualType_Name(value);
  }
  static inline bool visualType_Parse(const ::std::string& name,
      visualType* value) {
    return LessonFile_Visuals_visualType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .Guitar_learning.LessonFile.Visuals.visualType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Guitar_learning::LessonFile_Visuals_visualType type() const;
  inline void set_type(::Guitar_learning::LessonFile_Visuals_visualType value);
  
  // optional bytes header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const void* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  
  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Visuals)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* header_;
  ::std::string* data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Visuals* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile_Lesson : public ::google::protobuf::Message {
 public:
  LessonFile_Lesson();
  virtual ~LessonFile_Lesson();
  
  LessonFile_Lesson(const LessonFile_Lesson& from);
  
  inline LessonFile_Lesson& operator=(const LessonFile_Lesson& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile_Lesson& default_instance();
  
  void Swap(LessonFile_Lesson* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile_Lesson* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile_Lesson& from);
  void MergeFrom(const LessonFile_Lesson& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Guitar_learning.LessonFile.Track track = 1;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 1;
  inline const ::Guitar_learning::LessonFile_Track& track() const;
  inline ::Guitar_learning::LessonFile_Track* mutable_track();
  inline ::Guitar_learning::LessonFile_Track* release_track();
  
  // optional uint32 bpm = 2;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 2;
  inline ::google::protobuf::uint32 bpm() const;
  inline void set_bpm(::google::protobuf::uint32 value);
  
  // optional .Guitar_learning.LessonFile.bgMysic bg_music = 3;
  inline bool has_bg_music() const;
  inline void clear_bg_music();
  static const int kBgMusicFieldNumber = 3;
  inline const ::Guitar_learning::LessonFile_bgMysic& bg_music() const;
  inline ::Guitar_learning::LessonFile_bgMysic* mutable_bg_music();
  inline ::Guitar_learning::LessonFile_bgMysic* release_bg_music();
  
  // optional .Guitar_learning.LessonFile.Visuals visuals = 4;
  inline bool has_visuals() const;
  inline void clear_visuals();
  static const int kVisualsFieldNumber = 4;
  inline const ::Guitar_learning::LessonFile_Visuals& visuals() const;
  inline ::Guitar_learning::LessonFile_Visuals* mutable_visuals();
  inline ::Guitar_learning::LessonFile_Visuals* release_visuals();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile.Lesson)
 private:
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_bg_music();
  inline void clear_has_bg_music();
  inline void set_has_visuals();
  inline void clear_has_visuals();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Guitar_learning::LessonFile_Track* track_;
  ::Guitar_learning::LessonFile_bgMysic* bg_music_;
  ::Guitar_learning::LessonFile_Visuals* visuals_;
  ::google::protobuf::uint32 bpm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile_Lesson* default_instance_;
};
// -------------------------------------------------------------------

class LessonFile : public ::google::protobuf::Message {
 public:
  LessonFile();
  virtual ~LessonFile();
  
  LessonFile(const LessonFile& from);
  
  inline LessonFile& operator=(const LessonFile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LessonFile& default_instance();
  
  void Swap(LessonFile* other);
  
  // implements Message ----------------------------------------------
  
  LessonFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessonFile& from);
  void MergeFrom(const LessonFile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef LessonFile_Tone Tone;
  typedef LessonFile_Note Note;
  typedef LessonFile_Bar Bar;
  typedef LessonFile_Track Track;
  typedef LessonFile_bgMysic bgMysic;
  typedef LessonFile_Visuals Visuals;
  typedef LessonFile_Lesson Lesson;
  
  typedef LessonFile_NoteLength NoteLength;
  static const NoteLength nl64 = LessonFile_NoteLength_nl64;
  static const NoteLength nl32 = LessonFile_NoteLength_nl32;
  static const NoteLength nl16 = LessonFile_NoteLength_nl16;
  static const NoteLength nl8 = LessonFile_NoteLength_nl8;
  static const NoteLength nl4 = LessonFile_NoteLength_nl4;
  static const NoteLength nl2 = LessonFile_NoteLength_nl2;
  static const NoteLength nl1 = LessonFile_NoteLength_nl1;
  static inline bool NoteLength_IsValid(int value) {
    return LessonFile_NoteLength_IsValid(value);
  }
  static const NoteLength NoteLength_MIN =
    LessonFile_NoteLength_NoteLength_MIN;
  static const NoteLength NoteLength_MAX =
    LessonFile_NoteLength_NoteLength_MAX;
  static const int NoteLength_ARRAYSIZE =
    LessonFile_NoteLength_NoteLength_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NoteLength_descriptor() {
    return LessonFile_NoteLength_descriptor();
  }
  static inline const ::std::string& NoteLength_Name(NoteLength value) {
    return LessonFile_NoteLength_Name(value);
  }
  static inline bool NoteLength_Parse(const ::std::string& name,
      NoteLength* value) {
    return LessonFile_NoteLength_Parse(name, value);
  }
  
  typedef LessonFile_ClefType ClefType;
  static const ClefType treble = LessonFile_ClefType_treble;
  static const ClefType bass = LessonFile_ClefType_bass;
  static inline bool ClefType_IsValid(int value) {
    return LessonFile_ClefType_IsValid(value);
  }
  static const ClefType ClefType_MIN =
    LessonFile_ClefType_ClefType_MIN;
  static const ClefType ClefType_MAX =
    LessonFile_ClefType_ClefType_MAX;
  static const int ClefType_ARRAYSIZE =
    LessonFile_ClefType_ClefType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ClefType_descriptor() {
    return LessonFile_ClefType_descriptor();
  }
  static inline const ::std::string& ClefType_Name(ClefType value) {
    return LessonFile_ClefType_Name(value);
  }
  static inline bool ClefType_Parse(const ::std::string& name,
      ClefType* value) {
    return LessonFile_ClefType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string creator = 1;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 1;
  inline const ::std::string& creator() const;
  inline void set_creator(const ::std::string& value);
  inline void set_creator(const char* value);
  inline void set_creator(const char* value, size_t size);
  inline ::std::string* mutable_creator();
  inline ::std::string* release_creator();
  
  // required .Guitar_learning.LessonFile.Lesson lesson = 2;
  inline bool has_lesson() const;
  inline void clear_lesson();
  static const int kLessonFieldNumber = 2;
  inline const ::Guitar_learning::LessonFile_Lesson& lesson() const;
  inline ::Guitar_learning::LessonFile_Lesson* mutable_lesson();
  inline ::Guitar_learning::LessonFile_Lesson* release_lesson();
  
  // optional string signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  
  // @@protoc_insertion_point(class_scope:Guitar_learning.LessonFile)
 private:
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_lesson();
  inline void clear_has_lesson();
  inline void set_has_signature();
  inline void clear_has_signature();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* creator_;
  ::Guitar_learning::LessonFile_Lesson* lesson_;
  ::std::string* signature_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_LessonFile_2eproto();
  friend void protobuf_AssignDesc_LessonFile_2eproto();
  friend void protobuf_ShutdownFile_LessonFile_2eproto();
  
  void InitAsDefaultInstance();
  static LessonFile* default_instance_;
};
// ===================================================================


// ===================================================================

// LessonFile_Tone

// required double pitch = 1;
inline bool LessonFile_Tone::has_pitch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Tone::set_has_pitch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Tone::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Tone::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double LessonFile_Tone::pitch() const {
  return pitch_;
}
inline void LessonFile_Tone::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
}

// optional uint32 str = 2 [default = 0];
inline bool LessonFile_Tone::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Tone::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Tone::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Tone::clear_str() {
  str_ = 0u;
  clear_has_str();
}
inline ::google::protobuf::uint32 LessonFile_Tone::str() const {
  return str_;
}
inline void LessonFile_Tone::set_str(::google::protobuf::uint32 value) {
  set_has_str();
  str_ = value;
}

// -------------------------------------------------------------------

// LessonFile_Note

// required .Guitar_learning.LessonFile.NoteLength length = 1;
inline bool LessonFile_Note::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Note::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Note::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Note::clear_length() {
  length_ = 1;
  clear_has_length();
}
inline ::Guitar_learning::LessonFile_NoteLength LessonFile_Note::length() const {
  return static_cast< ::Guitar_learning::LessonFile_NoteLength >(length_);
}
inline void LessonFile_Note::set_length(::Guitar_learning::LessonFile_NoteLength value) {
  GOOGLE_DCHECK(::Guitar_learning::LessonFile_NoteLength_IsValid(value));
  set_has_length();
  length_ = value;
}

// required uint32 extension = 2;
inline bool LessonFile_Note::has_extension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Note::set_has_extension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Note::clear_has_extension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Note::clear_extension() {
  extension_ = 0u;
  clear_has_extension();
}
inline ::google::protobuf::uint32 LessonFile_Note::extension() const {
  return extension_;
}
inline void LessonFile_Note::set_extension(::google::protobuf::uint32 value) {
  set_has_extension();
  extension_ = value;
}

// optional bool continueTo = 3;
inline bool LessonFile_Note::has_continueto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_Note::set_has_continueto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_Note::clear_has_continueto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_Note::clear_continueto() {
  continueto_ = false;
  clear_has_continueto();
}
inline bool LessonFile_Note::continueto() const {
  return continueto_;
}
inline void LessonFile_Note::set_continueto(bool value) {
  set_has_continueto();
  continueto_ = value;
}

// optional bool continuedFrom = 4;
inline bool LessonFile_Note::has_continuedfrom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LessonFile_Note::set_has_continuedfrom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LessonFile_Note::clear_has_continuedfrom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LessonFile_Note::clear_continuedfrom() {
  continuedfrom_ = false;
  clear_has_continuedfrom();
}
inline bool LessonFile_Note::continuedfrom() const {
  return continuedfrom_;
}
inline void LessonFile_Note::set_continuedfrom(bool value) {
  set_has_continuedfrom();
  continuedfrom_ = value;
}

// optional bool slideTo = 5;
inline bool LessonFile_Note::has_slideto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LessonFile_Note::set_has_slideto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LessonFile_Note::clear_has_slideto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LessonFile_Note::clear_slideto() {
  slideto_ = false;
  clear_has_slideto();
}
inline bool LessonFile_Note::slideto() const {
  return slideto_;
}
inline void LessonFile_Note::set_slideto(bool value) {
  set_has_slideto();
  slideto_ = value;
}

// optional bool slidedFrom = 6;
inline bool LessonFile_Note::has_slidedfrom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LessonFile_Note::set_has_slidedfrom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LessonFile_Note::clear_has_slidedfrom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LessonFile_Note::clear_slidedfrom() {
  slidedfrom_ = false;
  clear_has_slidedfrom();
}
inline bool LessonFile_Note::slidedfrom() const {
  return slidedfrom_;
}
inline void LessonFile_Note::set_slidedfrom(bool value) {
  set_has_slidedfrom();
  slidedfrom_ = value;
}

// optional bool vibrato = 7;
inline bool LessonFile_Note::has_vibrato() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LessonFile_Note::set_has_vibrato() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LessonFile_Note::clear_has_vibrato() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LessonFile_Note::clear_vibrato() {
  vibrato_ = false;
  clear_has_vibrato();
}
inline bool LessonFile_Note::vibrato() const {
  return vibrato_;
}
inline void LessonFile_Note::set_vibrato(bool value) {
  set_has_vibrato();
  vibrato_ = value;
}

// optional bool HO = 8;
inline bool LessonFile_Note::has_ho() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LessonFile_Note::set_has_ho() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LessonFile_Note::clear_has_ho() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LessonFile_Note::clear_ho() {
  ho_ = false;
  clear_has_ho();
}
inline bool LessonFile_Note::ho() const {
  return ho_;
}
inline void LessonFile_Note::set_ho(bool value) {
  set_has_ho();
  ho_ = value;
}

// optional bool PO = 9;
inline bool LessonFile_Note::has_po() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LessonFile_Note::set_has_po() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LessonFile_Note::clear_has_po() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LessonFile_Note::clear_po() {
  po_ = false;
  clear_has_po();
}
inline bool LessonFile_Note::po() const {
  return po_;
}
inline void LessonFile_Note::set_po(bool value) {
  set_has_po();
  po_ = value;
}

// optional uint32 grouping = 10;
inline bool LessonFile_Note::has_grouping() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LessonFile_Note::set_has_grouping() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LessonFile_Note::clear_has_grouping() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LessonFile_Note::clear_grouping() {
  grouping_ = 0u;
  clear_has_grouping();
}
inline ::google::protobuf::uint32 LessonFile_Note::grouping() const {
  return grouping_;
}
inline void LessonFile_Note::set_grouping(::google::protobuf::uint32 value) {
  set_has_grouping();
  grouping_ = value;
}

// optional uint32 ungrouping = 11;
inline bool LessonFile_Note::has_ungrouping() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LessonFile_Note::set_has_ungrouping() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LessonFile_Note::clear_has_ungrouping() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LessonFile_Note::clear_ungrouping() {
  ungrouping_ = 0u;
  clear_has_ungrouping();
}
inline ::google::protobuf::uint32 LessonFile_Note::ungrouping() const {
  return ungrouping_;
}
inline void LessonFile_Note::set_ungrouping(::google::protobuf::uint32 value) {
  set_has_ungrouping();
  ungrouping_ = value;
}

// optional bool in_group = 12;
inline bool LessonFile_Note::has_in_group() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LessonFile_Note::set_has_in_group() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LessonFile_Note::clear_has_in_group() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LessonFile_Note::clear_in_group() {
  in_group_ = false;
  clear_has_in_group();
}
inline bool LessonFile_Note::in_group() const {
  return in_group_;
}
inline void LessonFile_Note::set_in_group(bool value) {
  set_has_in_group();
  in_group_ = value;
}

// repeated .Guitar_learning.LessonFile.Tone tone = 13;
inline int LessonFile_Note::tone_size() const {
  return tone_.size();
}
inline void LessonFile_Note::clear_tone() {
  tone_.Clear();
}
inline const ::Guitar_learning::LessonFile_Tone& LessonFile_Note::tone(int index) const {
  return tone_.Get(index);
}
inline ::Guitar_learning::LessonFile_Tone* LessonFile_Note::mutable_tone(int index) {
  return tone_.Mutable(index);
}
inline ::Guitar_learning::LessonFile_Tone* LessonFile_Note::add_tone() {
  return tone_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Tone >&
LessonFile_Note::tone() const {
  return tone_;
}
inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Tone >*
LessonFile_Note::mutable_tone() {
  return &tone_;
}

// -------------------------------------------------------------------

// LessonFile_Bar

// optional uint32 id = 1;
inline bool LessonFile_Bar::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Bar::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Bar::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Bar::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 LessonFile_Bar::id() const {
  return id_;
}
inline void LessonFile_Bar::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 length = 2;
inline bool LessonFile_Bar::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Bar::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Bar::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Bar::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 LessonFile_Bar::length() const {
  return length_;
}
inline void LessonFile_Bar::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// optional bool repeat_start = 3;
inline bool LessonFile_Bar::has_repeat_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_Bar::set_has_repeat_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_Bar::clear_has_repeat_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_Bar::clear_repeat_start() {
  repeat_start_ = false;
  clear_has_repeat_start();
}
inline bool LessonFile_Bar::repeat_start() const {
  return repeat_start_;
}
inline void LessonFile_Bar::set_repeat_start(bool value) {
  set_has_repeat_start();
  repeat_start_ = value;
}

// optional uint32 repeat_end = 4 [default = 1];
inline bool LessonFile_Bar::has_repeat_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LessonFile_Bar::set_has_repeat_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LessonFile_Bar::clear_has_repeat_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LessonFile_Bar::clear_repeat_end() {
  repeat_end_ = 1u;
  clear_has_repeat_end();
}
inline ::google::protobuf::uint32 LessonFile_Bar::repeat_end() const {
  return repeat_end_;
}
inline void LessonFile_Bar::set_repeat_end(::google::protobuf::uint32 value) {
  set_has_repeat_end();
  repeat_end_ = value;
}

// optional uint32 next_repeat_ending = 5 [default = 0];
inline bool LessonFile_Bar::has_next_repeat_ending() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LessonFile_Bar::set_has_next_repeat_ending() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LessonFile_Bar::clear_has_next_repeat_ending() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LessonFile_Bar::clear_next_repeat_ending() {
  next_repeat_ending_ = 0u;
  clear_has_next_repeat_ending();
}
inline ::google::protobuf::uint32 LessonFile_Bar::next_repeat_ending() const {
  return next_repeat_ending_;
}
inline void LessonFile_Bar::set_next_repeat_ending(::google::protobuf::uint32 value) {
  set_has_next_repeat_ending();
  next_repeat_ending_ = value;
}

// optional string bar_chord = 6;
inline bool LessonFile_Bar::has_bar_chord() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LessonFile_Bar::set_has_bar_chord() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LessonFile_Bar::clear_has_bar_chord() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LessonFile_Bar::clear_bar_chord() {
  if (bar_chord_ != &::google::protobuf::internal::kEmptyString) {
    bar_chord_->clear();
  }
  clear_has_bar_chord();
}
inline const ::std::string& LessonFile_Bar::bar_chord() const {
  return *bar_chord_;
}
inline void LessonFile_Bar::set_bar_chord(const ::std::string& value) {
  set_has_bar_chord();
  if (bar_chord_ == &::google::protobuf::internal::kEmptyString) {
    bar_chord_ = new ::std::string;
  }
  bar_chord_->assign(value);
}
inline void LessonFile_Bar::set_bar_chord(const char* value) {
  set_has_bar_chord();
  if (bar_chord_ == &::google::protobuf::internal::kEmptyString) {
    bar_chord_ = new ::std::string;
  }
  bar_chord_->assign(value);
}
inline void LessonFile_Bar::set_bar_chord(const char* value, size_t size) {
  set_has_bar_chord();
  if (bar_chord_ == &::google::protobuf::internal::kEmptyString) {
    bar_chord_ = new ::std::string;
  }
  bar_chord_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile_Bar::mutable_bar_chord() {
  set_has_bar_chord();
  if (bar_chord_ == &::google::protobuf::internal::kEmptyString) {
    bar_chord_ = new ::std::string;
  }
  return bar_chord_;
}
inline ::std::string* LessonFile_Bar::release_bar_chord() {
  clear_has_bar_chord();
  if (bar_chord_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bar_chord_;
    bar_chord_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Guitar_learning.LessonFile.Note notes = 7;
inline int LessonFile_Bar::notes_size() const {
  return notes_.size();
}
inline void LessonFile_Bar::clear_notes() {
  notes_.Clear();
}
inline const ::Guitar_learning::LessonFile_Note& LessonFile_Bar::notes(int index) const {
  return notes_.Get(index);
}
inline ::Guitar_learning::LessonFile_Note* LessonFile_Bar::mutable_notes(int index) {
  return notes_.Mutable(index);
}
inline ::Guitar_learning::LessonFile_Note* LessonFile_Bar::add_notes() {
  return notes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Note >&
LessonFile_Bar::notes() const {
  return notes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Note >*
LessonFile_Bar::mutable_notes() {
  return &notes_;
}

// -------------------------------------------------------------------

// LessonFile_Track

// required .Guitar_learning.LessonFile.ClefType clef = 1;
inline bool LessonFile_Track::has_clef() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Track::set_has_clef() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Track::clear_has_clef() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Track::clear_clef() {
  clef_ = 1;
  clear_has_clef();
}
inline ::Guitar_learning::LessonFile_ClefType LessonFile_Track::clef() const {
  return static_cast< ::Guitar_learning::LessonFile_ClefType >(clef_);
}
inline void LessonFile_Track::set_clef(::Guitar_learning::LessonFile_ClefType value) {
  GOOGLE_DCHECK(::Guitar_learning::LessonFile_ClefType_IsValid(value));
  set_has_clef();
  clef_ = value;
}

// required uint32 beat_count = 2;
inline bool LessonFile_Track::has_beat_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Track::set_has_beat_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Track::clear_has_beat_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Track::clear_beat_count() {
  beat_count_ = 0u;
  clear_has_beat_count();
}
inline ::google::protobuf::uint32 LessonFile_Track::beat_count() const {
  return beat_count_;
}
inline void LessonFile_Track::set_beat_count(::google::protobuf::uint32 value) {
  set_has_beat_count();
  beat_count_ = value;
}

// required uint32 beat_length = 3;
inline bool LessonFile_Track::has_beat_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_Track::set_has_beat_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_Track::clear_has_beat_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_Track::clear_beat_length() {
  beat_length_ = 0u;
  clear_has_beat_length();
}
inline ::google::protobuf::uint32 LessonFile_Track::beat_length() const {
  return beat_length_;
}
inline void LessonFile_Track::set_beat_length(::google::protobuf::uint32 value) {
  set_has_beat_length();
  beat_length_ = value;
}

// repeated .Guitar_learning.LessonFile.Bar bars = 4;
inline int LessonFile_Track::bars_size() const {
  return bars_.size();
}
inline void LessonFile_Track::clear_bars() {
  bars_.Clear();
}
inline const ::Guitar_learning::LessonFile_Bar& LessonFile_Track::bars(int index) const {
  return bars_.Get(index);
}
inline ::Guitar_learning::LessonFile_Bar* LessonFile_Track::mutable_bars(int index) {
  return bars_.Mutable(index);
}
inline ::Guitar_learning::LessonFile_Bar* LessonFile_Track::add_bars() {
  return bars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Bar >&
LessonFile_Track::bars() const {
  return bars_;
}
inline ::google::protobuf::RepeatedPtrField< ::Guitar_learning::LessonFile_Bar >*
LessonFile_Track::mutable_bars() {
  return &bars_;
}

// -------------------------------------------------------------------

// LessonFile_bgMysic

// required .Guitar_learning.LessonFile.bgMysic.bgType type = 1;
inline bool LessonFile_bgMysic::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_bgMysic::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_bgMysic::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_bgMysic::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Guitar_learning::LessonFile_bgMysic_bgType LessonFile_bgMysic::type() const {
  return static_cast< ::Guitar_learning::LessonFile_bgMysic_bgType >(type_);
}
inline void LessonFile_bgMysic::set_type(::Guitar_learning::LessonFile_bgMysic_bgType value) {
  GOOGLE_DCHECK(::Guitar_learning::LessonFile_bgMysic_bgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes header = 2;
inline bool LessonFile_bgMysic::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_bgMysic::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_bgMysic::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_bgMysic::clear_header() {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& LessonFile_bgMysic::header() const {
  return *header_;
}
inline void LessonFile_bgMysic::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LessonFile_bgMysic::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LessonFile_bgMysic::set_header(const void* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile_bgMysic::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  return header_;
}
inline ::std::string* LessonFile_bgMysic::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 3;
inline bool LessonFile_bgMysic::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_bgMysic::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_bgMysic::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_bgMysic::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LessonFile_bgMysic::data() const {
  return *data_;
}
inline void LessonFile_bgMysic::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LessonFile_bgMysic::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LessonFile_bgMysic::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile_bgMysic::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* LessonFile_bgMysic::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LessonFile_Visuals

// required .Guitar_learning.LessonFile.Visuals.visualType type = 1;
inline bool LessonFile_Visuals::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Visuals::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Visuals::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Visuals::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Guitar_learning::LessonFile_Visuals_visualType LessonFile_Visuals::type() const {
  return static_cast< ::Guitar_learning::LessonFile_Visuals_visualType >(type_);
}
inline void LessonFile_Visuals::set_type(::Guitar_learning::LessonFile_Visuals_visualType value) {
  GOOGLE_DCHECK(::Guitar_learning::LessonFile_Visuals_visualType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes header = 2;
inline bool LessonFile_Visuals::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Visuals::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Visuals::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Visuals::clear_header() {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& LessonFile_Visuals::header() const {
  return *header_;
}
inline void LessonFile_Visuals::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LessonFile_Visuals::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void LessonFile_Visuals::set_header(const void* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile_Visuals::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  return header_;
}
inline ::std::string* LessonFile_Visuals::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes data = 3;
inline bool LessonFile_Visuals::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_Visuals::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_Visuals::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_Visuals::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LessonFile_Visuals::data() const {
  return *data_;
}
inline void LessonFile_Visuals::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LessonFile_Visuals::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LessonFile_Visuals::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile_Visuals::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* LessonFile_Visuals::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LessonFile_Lesson

// required .Guitar_learning.LessonFile.Track track = 1;
inline bool LessonFile_Lesson::has_track() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile_Lesson::set_has_track() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile_Lesson::clear_has_track() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile_Lesson::clear_track() {
  if (track_ != NULL) track_->::Guitar_learning::LessonFile_Track::Clear();
  clear_has_track();
}
inline const ::Guitar_learning::LessonFile_Track& LessonFile_Lesson::track() const {
  return track_ != NULL ? *track_ : *default_instance_->track_;
}
inline ::Guitar_learning::LessonFile_Track* LessonFile_Lesson::mutable_track() {
  set_has_track();
  if (track_ == NULL) track_ = new ::Guitar_learning::LessonFile_Track;
  return track_;
}
inline ::Guitar_learning::LessonFile_Track* LessonFile_Lesson::release_track() {
  clear_has_track();
  ::Guitar_learning::LessonFile_Track* temp = track_;
  track_ = NULL;
  return temp;
}

// optional uint32 bpm = 2;
inline bool LessonFile_Lesson::has_bpm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile_Lesson::set_has_bpm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile_Lesson::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile_Lesson::clear_bpm() {
  bpm_ = 0u;
  clear_has_bpm();
}
inline ::google::protobuf::uint32 LessonFile_Lesson::bpm() const {
  return bpm_;
}
inline void LessonFile_Lesson::set_bpm(::google::protobuf::uint32 value) {
  set_has_bpm();
  bpm_ = value;
}

// optional .Guitar_learning.LessonFile.bgMysic bg_music = 3;
inline bool LessonFile_Lesson::has_bg_music() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile_Lesson::set_has_bg_music() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile_Lesson::clear_has_bg_music() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile_Lesson::clear_bg_music() {
  if (bg_music_ != NULL) bg_music_->::Guitar_learning::LessonFile_bgMysic::Clear();
  clear_has_bg_music();
}
inline const ::Guitar_learning::LessonFile_bgMysic& LessonFile_Lesson::bg_music() const {
  return bg_music_ != NULL ? *bg_music_ : *default_instance_->bg_music_;
}
inline ::Guitar_learning::LessonFile_bgMysic* LessonFile_Lesson::mutable_bg_music() {
  set_has_bg_music();
  if (bg_music_ == NULL) bg_music_ = new ::Guitar_learning::LessonFile_bgMysic;
  return bg_music_;
}
inline ::Guitar_learning::LessonFile_bgMysic* LessonFile_Lesson::release_bg_music() {
  clear_has_bg_music();
  ::Guitar_learning::LessonFile_bgMysic* temp = bg_music_;
  bg_music_ = NULL;
  return temp;
}

// optional .Guitar_learning.LessonFile.Visuals visuals = 4;
inline bool LessonFile_Lesson::has_visuals() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LessonFile_Lesson::set_has_visuals() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LessonFile_Lesson::clear_has_visuals() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LessonFile_Lesson::clear_visuals() {
  if (visuals_ != NULL) visuals_->::Guitar_learning::LessonFile_Visuals::Clear();
  clear_has_visuals();
}
inline const ::Guitar_learning::LessonFile_Visuals& LessonFile_Lesson::visuals() const {
  return visuals_ != NULL ? *visuals_ : *default_instance_->visuals_;
}
inline ::Guitar_learning::LessonFile_Visuals* LessonFile_Lesson::mutable_visuals() {
  set_has_visuals();
  if (visuals_ == NULL) visuals_ = new ::Guitar_learning::LessonFile_Visuals;
  return visuals_;
}
inline ::Guitar_learning::LessonFile_Visuals* LessonFile_Lesson::release_visuals() {
  clear_has_visuals();
  ::Guitar_learning::LessonFile_Visuals* temp = visuals_;
  visuals_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LessonFile

// optional string creator = 1;
inline bool LessonFile::has_creator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LessonFile::set_has_creator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LessonFile::clear_has_creator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LessonFile::clear_creator() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    creator_->clear();
  }
  clear_has_creator();
}
inline const ::std::string& LessonFile::creator() const {
  return *creator_;
}
inline void LessonFile::set_creator(const ::std::string& value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void LessonFile::set_creator(const char* value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void LessonFile::set_creator(const char* value, size_t size) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile::mutable_creator() {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  return creator_;
}
inline ::std::string* LessonFile::release_creator() {
  clear_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_;
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .Guitar_learning.LessonFile.Lesson lesson = 2;
inline bool LessonFile::has_lesson() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessonFile::set_has_lesson() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessonFile::clear_has_lesson() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessonFile::clear_lesson() {
  if (lesson_ != NULL) lesson_->::Guitar_learning::LessonFile_Lesson::Clear();
  clear_has_lesson();
}
inline const ::Guitar_learning::LessonFile_Lesson& LessonFile::lesson() const {
  return lesson_ != NULL ? *lesson_ : *default_instance_->lesson_;
}
inline ::Guitar_learning::LessonFile_Lesson* LessonFile::mutable_lesson() {
  set_has_lesson();
  if (lesson_ == NULL) lesson_ = new ::Guitar_learning::LessonFile_Lesson;
  return lesson_;
}
inline ::Guitar_learning::LessonFile_Lesson* LessonFile::release_lesson() {
  clear_has_lesson();
  ::Guitar_learning::LessonFile_Lesson* temp = lesson_;
  lesson_ = NULL;
  return temp;
}

// optional string signature = 3;
inline bool LessonFile::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessonFile::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessonFile::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessonFile::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& LessonFile::signature() const {
  return *signature_;
}
inline void LessonFile::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void LessonFile::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void LessonFile::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LessonFile::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* LessonFile::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Guitar_learning

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Guitar_learning::LessonFile_bgMysic_bgType>() {
  return ::Guitar_learning::LessonFile_bgMysic_bgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Guitar_learning::LessonFile_Visuals_visualType>() {
  return ::Guitar_learning::LessonFile_Visuals_visualType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Guitar_learning::LessonFile_NoteLength>() {
  return ::Guitar_learning::LessonFile_NoteLength_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Guitar_learning::LessonFile_ClefType>() {
  return ::Guitar_learning::LessonFile_ClefType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_LessonFile_2eproto__INCLUDED
